C51 COMPILER V9.01   MAIN                                                                  07/24/2016 14:44:14 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN ..\Output\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND PRINT(..\Listing\main.lst) OBJECT(..\Ou
                    -tput\main.obj)

line level    source

   1          /**********************************************************************************
   2           * 工程名  :拨打电话
   3          
   4           * 实验平台:STC12XX
   5           **********************************************************************************/
   6          #include "string.h"
   7          #include "delay.h"
   8          #include "uart.h"
   9          #define Buf2_Max 200                                      //串口2缓存长度
  10          /*************  本地常量声明    **************/
  11          sbit RUNING_LED = P2^1;                                 //运行指示灯
  12          
  13          /*************  本地变量声明    **************/
  14          xdata u8 Uart2_Buf[Buf2_Max];
  15          
  16          u8 Times=0,First_Int = 0,shijian=0;
  17          //u8 Time_count=0;
  18          bdata u8 Flag;//定时器标志位
  19          sbit Timer0_start =Flag^0;      //定时器0延时启动计数器
  20          static unsigned char *phone = "ATD10086;\r\n"; //拨打电话，修改这里可以修改拨打的电话。
  21          /*************  本地函数声明    **************/
  22          void GPIO_config(void);
  23          void Timer0Init(void);
  24          void CLR_Buf2(void);
  25          void Wait_CREG(void);
  26          /*******************************************************************************
  27          * 函数名 : main 
  28          * 描述   : 主函数
  29          * 输入   : 
  30          * 输出   : 
  31          * 返回   : 
  32          * 注意   : 串口2负责与GPRS模块通信，串口1用于下载程序或串口调试，可以避免在下载程序时数据还发送到模块
  33          *******************************************************************************/
  34          void main(void)
  35          {
  36   1              GPIO_config();
  37   1              Uart2Init();
  38   1              Timer0Init();
  39   1              EA=1;   //开总中断
  40   1              Wait_CREG();  //查询模块是否注册成功
  41   1              UART2_SendString(phone);  //拨打电话
  42   1              while(1)
  43   1              {
  44   2                      ;
  45   2              }       
  46   1      }
  47          /*******************************************************************************
  48          * 函数名 : Uart1 
  49          * 描述   : 串口1中断服务入口函数
  50          * 输入   : 
  51          * 输出   : 
  52          * 返回   : 
  53          * 注意   : 
  54          *******************************************************************************/
C51 COMPILER V9.01   MAIN                                                                  07/24/2016 14:44:14 PAGE 2   

  55          void Uart1() interrupt 4
  56          {
  57   1          if (RI)
  58   1          {
  59   2              RI = 0;                 //清除RI位
  60   2          }
  61   1          if (TI)
  62   1          {
  63   2              TI = 0;                 //清除TI位
  64   2          }
  65   1      }
  66          
  67          /*******************************************************************************
  68          * 函数名 : Uart2
  69          * 描述   : 串口2中断服务入口函数
  70          * 输入   : 
  71          * 输出   : 
  72          * 返回   : 
  73          * 注意   : 
  74          *******************************************************************************/
  75          void Uart2() interrupt 8
  76          {
  77   1                      IE2  &= ~0x01;   //关闭串口2中断
  78   1          if (S2CON & S2RI)
  79   1          {
  80   2            S2CON &= ~S2RI;         //清除S2RI位
  81   2                              Uart2_Buf[First_Int] = S2BUF;     //将接收到的字符串存到缓存中
  82   2                              First_Int++;                                    //缓存指针向后移动
  83   2                              if(First_Int > Buf2_Max)                //如果缓存满,将缓存指针指向缓存的首地址
  84   2                              {
  85   3                                      First_Int = 0;
  86   3                              }
  87   2          }
  88   1          if (S2CON & S2TI)
  89   1          {
  90   2            S2CON &= ~S2TI;         //清除S2TI位
  91   2          }
  92   1                      IE2  |= 0x01;   //使能串口2中断
  93   1      }
  94          /*******************************************************************************
  95          * 函数名 : Timer0_ISR
  96          * 描述   : 定时器0中断服务入口函数,20ms中断一次
  97          * 输入   : 
  98          * 输出   : 
  99          * 返回   : 
 100          * 注意   : 
 101          *******************************************************************************/
 102          void Timer0_ISR() interrupt 1
 103          {
 104   1              static u8 Time_count=0; 
 105   1              TR0=0;//关定时器
 106   1              Time_count++;
 107   1              if(Time_count>=50)
 108   1              {
 109   2                      Time_count = 0;
 110   2                      RUNING_LED =~RUNING_LED;
 111   2              }
 112   1      
 113   1              TR0=1;//开定时器
 114   1      }
 115          /*******************************************************************************
 116          * 函数名 : GPIO_config
C51 COMPILER V9.01   MAIN                                                                  07/24/2016 14:44:14 PAGE 3   

 117          * 描述   : IO口配置函数
 118          * 输入   : 
 119          * 输出   : 
 120          * 返回   : 
 121          * 注意   : 
 122          *******************************************************************************/
 123          void    GPIO_config(void)
 124          {
 125   1                      P3M1 &= 0XC3;  //配置P32~P35为推挽输出
 126   1                      P3M0 |= ~0XC3;
 127   1                      RUNING_LED=0;
 128   1      }
 129          void Timer0Init(void)           //20毫秒@22.1184MHz
 130          {
 131   1              AUXR &= 0x7F;   //12T模式
 132   1              TMOD &= 0xF0;   //设置定时器模式 16位重载
 133   1              TL0 = 0x00;             //设定定时器初值
 134   1              TH0 = 0x70;             //设定定时器初值
 135   1              TF0 = 0;                        //清除TF0标志
 136   1              TR0 = 1;                        //定时器0开始计时
 137   1              ET0 = 1;        //使能定时器0中断
 138   1      }
 139          /*******************************************************************************
 140          * 函数名 : CLR_Buf2
 141          * 描述   : 清除串口2缓存数据
 142          * 输入   : 
 143          * 输出   : 
 144          * 返回   : 
 145          * 注意   : 
 146          *******************************************************************************/
 147          void CLR_Buf2(void)
 148          {
 149   1              u16 k;
 150   1              for(k=0;k<Buf2_Max;k++)      //将缓存内容清零
 151   1              {
 152   2                      Uart2_Buf[k] = 0x00;
 153   2              }
 154   1          First_Int = 0;              //接收字符串的起始存储位置
 155   1      }
 156          
 157          /*******************************************************************************
 158          * 函数名 : Wait_CREG
 159          * 描述   : 等待模块注册成功
 160          * 输入   : 
 161          * 输出   : 
 162          * 返回   : 
 163          * 注意   : 
 164          *******************************************************************************/
 165          void Wait_CREG(void)
 166          {
 167   1              u8 i;
 168   1              u8 k;
 169   1              i = 0;
 170   1              CLR_Buf2();
 171   1        while(i == 0)                         
 172   1              {
 173   2                      CLR_Buf2();        
 174   2                      UART2_SendString("AT+CREG?");
 175   2                      UART2_SendLR();
 176   2                      delay_ms(5000);                                                 
 177   2                  for(k=0;k<Buf2_Max;k++)                             
 178   2              {
C51 COMPILER V9.01   MAIN                                                                  07/24/2016 14:44:14 PAGE 4   

 179   3                              if(Uart2_Buf[k] == ':')
 180   3                              {
 181   4                                      if((Uart2_Buf[k+4] == '1')||(Uart2_Buf[k+4] == '5'))  //说模块注册成功
 182   4                                      {
 183   5                                              i = 1;
 184   5                                        break;
 185   5                                      }
 186   4                              }
 187   3                      }
 188   2              }
 189   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    267    ----
   CONSTANT SIZE    =     21    ----
   XDATA SIZE       =    200    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      8       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
